今やっている改革の正体
一言でいうと

「V1で混線した FastAPI + SQLite アプリを
V2で“責務が壊れない構造”に再構築している」

何が壊れていたのか（改革前）
① 役割が崩壊していた

API が DB を直接触る

service が SQL の都合を知っている

repository が DTO 仕様を知らない

main.py が依存関係の境界になっていない

→ どこを直しても別の場所が壊れる構造

② DB 参照ルートが複数あった

各 service / repo が

独自に sqlite3.connect(...)

パスを直接指定

local / render / 永続 disk で

DB がズレる

再現不能

→ 本番とローカルの差異が消えない

③ V1 前提がコードに埋め込まれていた

farm_id が Body に入っていたり Query だったり

sqlite3.Row を dict 前提で扱っている箇所とそうでない箇所が混在

フロントは「昔の API 仕様」を前提にしている

→ API を変えた瞬間に全 UI が死ぬ

今やっている改革の中身
改革①：責務分離の固定
これを強制している
API  → 入出力契約だけ
service → ビジネスロジックだけ
repository → DB都合をすべて吸収


service は repo が何を返すかを信じる

repo が service に合わせる（逆はしない）

改革②：DB ルーティングの一本化
ゴール
from app_v2.db.core import resolve_db_path


DB パスの Single Source of Truth

local：app.db

render：永続ディスク

👉
どのページ・どの service でも
DB の行き先は絶対に一致する

改革③：V1 / V2 の共存運用
なぜ V2 を一気に切り替えないか

このアプリは 状態を持つ

一気に壊すと

何が原因かわからなくなる

rollback 不可能

だから

main.py で

V1 API と V2 API を明示的に切り替え

1ページずつ

完全互換を確認してから次へ

改革④：依存順の見直し
安全な順序

registration（独立）

farmer settings（farm 単体）

public / detail（参照のみ）

expanded（集約）

pickup（reservation 依存）

→
依存が少ないものから順に確定させる

なぜ今 farmer settings で地獄になったか

理由は単純。

farmer settings は

DB

画像

フロント契約

複数 update API
を同時に持つ 中規模ドメイン

ここで

repo が service の期待を満たしていない

API が Query / Body 契約を壊した

→
構造不整合が一気に露呈した

これは失敗ではなく、

「改革で一番価値がある場所に当たった」

という状態。

この改革が成功すると何が得られるか

Render / local 差異が消える

1ページずつ安全に改修できる

pickup / reservation の改革が現実的になる

将来 DB を PostgreSQL にしても

repo だけ差し替えれば済む



9. V2 改革の実践方法論（既存コードからの再構築手順）
9.1 方針：書き直しではなく「抽出と再配置」

V2 の registration は
1から新規実装したものではない。

元々存在していた以下のような状態から始まっている。

API / Service / Repo の責務が混在したファイル

一つのファイルが

HTTP 処理

業務判断

DB 操作
を同時に行っていた

この状態を 壊さずに、
役割ごとに“抜き出して”再構築した。

9.2 手順①：「真の API 部分」を抜き出す

最初にやったことは API の再定義。

見極め基準（API がやるべきこと）

HTTP リクエストを受け取る

入力項目を構造化する

前提条件を内部で注入する

Service を呼ぶ

結果を返す

逆に API から排除したもの

DB 参照

業務判断

状態チェックの詳細

実際の作業内容

既存の registration 関連ファイルから

Request / Response

HTTP ステータス処理

Service 呼び出し部分
だけを 物理的に抜き出す

それを元に
registration_v2_api.py を新規作成

👉 この時点では Service / Repo は未完成でもよい

9.3 手順②：「真の Service」を定義し直す

次に行ったのは Service の再構築。

見極め基準（Service がやるべきこと）

業務ルールの判断

処理順序の制御

初期状態の決定

エラー条件の定義

排除したもの

HTTP の知識

FastAPI 依存

Request / Response の形式

実際の作業内容

既存の Service / API / Repo に散らばっていた

if 判定

初期値設定

例外定義
を 1か所に集約

引数はすべて
「意味を持つ値」だけに統一

👉 Service は
「どこから来た値か」を知らない構造にした。

9.4 手順③：「真の Repository」を最後に作る

最後に Repo を作る。

見極め基準（Repo がやるべきこと）

DB に保存する

DB から取得する

SQL / カラム / 型を扱う

排除したもの

業務ルール

状態判断

HTTP / UI 文脈

実際の作業内容

既存コードの DB 操作部分だけを抽出

insert / select を単純化

Service から呼ばれる最小 API に整形

👉 Repo は
「意味を知らないが、正確に保存する存在」

9.5 なぜこの順序なのか（重要）

API → Service → Repo の順で作った理由は明確。

API を先に作る
→ 入力と出口が固定される

Service を作る
→ 業務ロジックの中心が定まる

Repo を作る
→ DB 実装を最後に押し込める

👉 DB を最後にすることで破壊範囲を最小化できる

9.6 この方法の最大の利点

既存コードを一切壊さずに進められる

途中で動作確認ができる

失敗しても元に戻せる

GPT が変わっても再現できる

(追記）
構造改革まとめ（V2 基準・保存版）
0. この文書の目的

本プロジェクトでは、
Stripe 決済・予約状態遷移・通知といった破壊的に複雑になりやすい領域に対し、
長期保守・将来拡張を前提とした構造改革（V2）を段階的に実施した。

この文書は：

今後の 保守・修正・追加開発時の判断基準

「どこを触ってよく、どこを触ってはいけないか」の明文化

line_api / notification / admin / farmer_pickup 改革時の 指針

を残すためのものである。

1. 構造改革の最重要原則（これを破ったら V1 に逆戻り）
原則①：DB 入口は必ず 1 本にする

唯一の正：resolve_db_path()

DB パス・sqlite3.connect は Repository のみ

NG 例

Service / API で sqlite3.connect("app.db")

DB_PATH = ... の直書き

OK 例
API
 └─ Service（DB 非関知）
     └─ Repository（resolve_db_path）

原則②：役割分担は絶対に混ぜない
レイヤー	責務	やってはいけないこと
API	HTTP 入出力	DB 直接操作
Service	業務判断・状態遷移	SQL / DB パス
Repository	DB I/O のみ	ビジネス判断
Client	外部 API	DB / Service 依存

「ちょっと便利だから」は 100% 技術的負債になる。

2. 今回確立した「正しい V2 の型」
① Stripe Checkout（完成形）
stripe_checkout_api.py
 └─ StripeCheckoutService
     └─ StripeCheckoutRepository
         └─ resolve_db_path()


Service は オーケストレーター

Repository は DB のみ

Client（Stripe SDK）は完全分離

② Stripe Webhook（完成形）
stripe_webhook_api.py
 └─ StripeWebhookService
     ├─ StripeWebhookRepository
     └─ ReservationStatusService


WebhookService は イベント解釈のみ

状態遷移は ReservationStatusService に集約

DB は Repository のみ

③ ReservationStatus（核）
ReservationStatusService
 └─ ReservationStatusRepository


予約状態の唯一の正

Checkout / Webhook / Notification すべてがここを通る

直接呼ばれても破綻しない設計

④ Notification（分離後の完成思想）
LineNotificationService（Facade）
 ├─ NotificationContextBuilder
 ├─ NotificationScheduler
 └─ NotificationDispatcher
     └─ LineClient


Service = Facade のみ

Context / Scheduling / Sending を完全分離

ReservationBooked / Admin / Stripe と安全に共存可能

3. なぜこの改革が「難所を突破できた」のか
✔ 一気にやらなかった

Stripe → Webhook → Status → Notification の 順序

動く状態を常に保持

✔ V1 を即削除しなかった

「完全移行までは消さない」

main.py の接続を慎重に維持

✔ 動作確認を常に優先

Booked / Admin / Notification が 同時に動くことを確認

「設計が正しくても壊れたら意味がない」

4. これから構造改革するファイルへの指針
🔸 line_api.py

最後にやる

直接 DB を触っていたら Repository 切り出し

まずは Facade 化だけで十分

🔸 notification 系

今回確立した構成を そのまま踏襲

新機能は必ず Builder / Scheduler / Dispatcher のどれかに入れる

🔸 admin 系

まず「参照専用」に割り切る

更新系は ReservationStatusService を通す

🔸 farmer_pickup

日時計算・表示変換は Domain / Util に逃がす

DB アクセスは Repo 以外禁止

5. 今後の保守・変更で迷ったら

次の質問に YES / NO で答える：

Service で DB を触っていないか？

Repository に判断ロジックを書いていないか？

状態遷移は ReservationStatusService を通っているか？

新しい責務を既存クラスに押し込んでいないか？

1 つでも NO があれば、
その変更は V2 を壊している。

6. 最後に（重要）

今回の改革で得た最大の成果は：

「難しい領域ほど、正しい構造にすれば“怖くなくなる”」

という実証です。

line_api / notification / admin / farmer_pickup は
もう “未知の地雷原” ではありません。

ここにある型を守る限り、
変更しても、追加しても、壊れません。